# Work with net

English | [Русский](./README.ru.md) 

Библиотека для работы с данными получаемыми из сети. Очень часто при работе с AJAX-запросами мы получаем данные в формате base64, или данные в двоичном формате. Просто так отобразить их не получится. Данная библиотека содержит модули, которые преобразуют расширения файлов в mime types, mime types в обычные расширения файлов. Модулей, которые позволяют скачивать файлы приходящие через AJAX-запрос, открывать эти данные в новой вкладке, работа с base64.

Для того, чтобы установить данную библиотеку необходимо в консоли набрать:

```
npm i work-with-net
```

После установки вы можете подключать как саму библиотеку, так и конкретные ее модули.

- Подключение отдельных модулей - import { downloadFile, openFile, getFileExtension, getMimeType, base64Code, base64Encode, base64FileEncode, downloadCSV, convertBase64ToBinary, downloadFileByExt } from "work-with-net";
- Или подключите всю библиотеку - import workWithNet from "work-with-net";

По умолчанию моя библиотека содержит порядка 800 mime types, спасибо за это [Robert Kieffer](https://github.com/broofa/mime). Это достаточно много, но работать будет вообще для всего. Размер правда при этом будет около 40kb. Если же вам нужны стандартные расширения, то подключите самые распространенные типы:

- Подключение отдельных модулей - import { downloadFile, openFile, getFileExtension, getMimeType, base64Code, base64Encode, base64FileEncode, downloadCSV, convertBase64ToBinary, downloadFileByExt } from "work-with-net/lib/work-with-net-standard.js";
- Или подключите всю библиотеку - import workWithNet from "work-with-net/lib/work-with-net-standard.js";

При таком подключении размер будет около 3kb. Тут только самые типовые расширения. Первоначально у меня стояла задача сделать чат для работы с менеджером, предполагалось, что пользователь через этот чат будет переписываться с менеджером, загружать или скачивать от него документы. Список расширений мне предоставили, я его не много дополнил. Давайте я его приложу:

- "7z";
- "gz";
- "zip";
- "rar";
- "tar";
- "tif";
- "jpeg";
- "png";
- "svg";
- "bmp";
- "odp";
- "ods";
- "txt";
- "xml";
- "csv";
- "odt";
- "docx";
- "dotx";
- "docm";
- "dotm";
- "doc";
- "xls";
- "xlsx";
- "xltx";
- "xlsm";
- "xltm";
- "xlam";
- "xlsb";
- "ppt";
- "pptx";
- "potx";
- "ppsx";
- "ppam";
- "pptm";
- "potm";
- "ppsm";
- "mdb";
- "pdf";
- "rtf";

Как видите это наиболее распространненые расширения для работы с документами, архивами, картинками. Чат был деловой, музыку туда нельзя было закинуть, в будующем я возможно это поправлю.

Если вам нужна поддержка IE 11 то подключите библиотеку следующим образом:

- Подключение отдельных модулей - import { downloadFile, openFile, getFileExtension, getMimeType, base64Code, base64Encode, base64FileEncode, downloadCSV, convertBase64ToBinary, downloadFileByExt } from "work-with-net/lib/ie/work-with-net-standard.js";
- Или подключите всю библиотеку - import workWithNet from "work-with-net/lib/ie/work-with-net-standard.js";

Сразу хочу сказать, для 11 IE я не проверял, подключайте на свой риск.

## Получение mime types из расширений файлов и на оборот.

Для получения mime type из расширения файла используйте функцию getMimeType('расширений файла'). Вам это скорее всего не пригодится, в большинстве случаев вы будете получать расширения файла из mime type. Для этого существует функция getFileExtension('mime type'). Если вы подключили всю библиотеку то тогда:

- workWithNet.getMimeType('расширений файла') - получить mime type из расширения файла;
- workWithNet.getFileExtension('mime type') - получить расширение файла из mime type.

## Скачать файл из AJAX-запроса, или открыть его в новой вкладке.

Если вы получаете файл из AJAX-запроса (в базе данных он лежит в двоичном виде, для его преобразования я использую blob). То для его скачивания используйте функцию downloadFile('файл в двоичном виде', 'mime type', 'имя файла'). Смотрите, вам обязательно нужен сам файл, и его mime type. Mime type как правило лежит в заголовке ответа (Content-Type). Если имя файла не задать, то при скачивании имя файла будет содержать дату в милисекундах с 1970 года. Если вы что-то скачивали через портал гос. услуг, то там файлы качаются также. Если же вам нужно имя как-то конкретно генерить, то задайте 3 параметр, так он не обязателен.

Если нужно открыть файл в новой вкладке то используйте функцию openFile('файл в двоичном виде'). Как правило задача может стоять так, что pdf-файлы мы открываем в новой вкладке, а все остальный файлы нужно скачивать. Соответственно из "Content-Type" мы получаем mime type файла, преобразуем его через 'getFileExtension' и в зависимости от его расширения вызываем или 'getFileExtension', или 'getMimeType'. Тут есть одно но, не все файлы можно открыть в браузере. Документ pdf откроется, а вот ISO-образ нет, он у вас скачается. Тут ничего не поделать.

Бывают такие случаи, что для скачивания файла вам не нужно знать его mime type. К примеру вы заранее знаете, что к вам по AJAX запросу придут jpeg-картинки. Или другой вариант, вам нужно сгенерить torrent-файл. Для этого есть функция downloadFileByExt('файл в двоичнов виде, 'его расширение', 'имя файла'). Смотрие, вам необходим сам файл, расширение по умолчанию у меня стоит jpeg (если вам нужно сгенерить jpeg, то можно расширение не задавать). Имя файла тоже не обязательный параметр. Если имя файла не задать, то при скачивании имя файла будет содержать дату в милисекундах с 1970 года. Эта функция будет работать быстрее чем downloadFile, так как под капотом не будет вычисляться расширение файла.

Если вы подключили библиотеку, а не отдельные модули, то:

- workWithNet.downloadFile('файл в двоичном виде', 'mime type', 'имя файла') - скачать файл;
- workWithNet.openFile('файл в двоичном виде') - открыть файл в новой вкладке.
- workWithNet.downloadFileByExt('файл в двоичнов виде, 'его расширение', 'имя файла') - скачать файл если вы знаете его расширение.

## Работа с base64

Для работы с base64 существуют следующие функции base64Code, base64Encode, base64FileEncode, convertBase64ToBinary;

- base64Code('Текст') - преобразует текст в формат base64, как правило это нужно если вы из формы пароль отправляете при регистрации. Но это не всегда нужно, но так бывает;
- base64Encode('Текст') - преобразует base64 в текст, как правило если вы по AJAX-запросу получаете пароль, вам его нужно декодировать в обычный текст. Или галочка "запомнить меня", тут вам эта функция пригодится;
- base64FileEncode('base64', 'media type', 'кодировка') - если вы по AJAX запросу получаете файл в формате base64, то первый аргумент данной функции это сам файл в формате base64. Media type, он должен приходить из заголовка ответа (Content-Type), и кодировки. В большинстве случаев вам так будут приходить картинки, поэтому если у вас картинка в формате "jpeg", то media type можно не указывать, он у меня стоит по умолчанию, кодировка тоже скорее всего будет "utf-8", поэтому эти параметры не обязательны. В редких случаях кодировка будет не "utf-8", и возможно в base64 вам придет pdf-файл. Тогда данные аргументы будут иметь значение.
- convertBase64ToBinary('строка base64') - как можно понять из названия, это нужно для преобразования base64 в двоичный файл. Однажды мне по одному API приходили картинки в формате base64. Мне нужно было вставить их в SVG, нарисовать там фигуры, и потом отправить эти фигуры вместе с картинкой. Картинку нужно было отправлять в двоичном виде. Если дополнительно использовать модуль downloadFile, то можно полученную картинку в формате base64 преобразовать в двоичный файл, и скачать ее.

Если вы подключили библиотеку, а не отдельные модули, то:

- workWithNet.base64Code('Текст') - преобразует текст в формат base64;
- workWithNet.base64Encode('Текст') - преобразует base64 в текст;
- workWithNet.base64FileEncode('base64', 'media type', 'кодировка') - отобразить файл в формате base64.
- workWithNet.convertBase64ToBinary('строка base64') - для преобразования base64 в двоичный файл.

## Скачивание CSV-файла

На первый взгляд это простая задача. Что может быть проще, чем сгенерить CSV на javascript-е, но когда я начал ее решать, у меня возникло много проблем.

Первая проблема была с кодировкой. Все примеры в сети были с англоязычных форумов. У них все работало хорошо. В моем случае текст содержал кирилицу, как следствие он не отображался как нужно в excel-е. После получаса поисков, решение я нашел, нужно было подставить 3 символа для BOM-кодировки.

Вторая проблема заключалась в том, что текст был в одну колонку. Тут мне помогли ребята. Нужно было использовать в качестве разделителя ";".

В общем стало понятно, что это случай для моей библиотеки. Для того, чтобы сгенерить CSV-файл в моей библиотеке есть функция downloadCSV. Она принимает 2 параметра, массив массивов, из которых я буду строить CSV-файл, и имя файла. Имя файла не обязательный параметр. Если его не задавать, будет подставлено время в милисекундах с 1970 года. Давайте я лучше покажу пример для наглядности.

```
import { downloadCSV } from 'work-with-net';

const csvArr = [
  [1, 2, 3],
  ['какой-то текст 1', '"' + 'какой-то ; \\n текст 2' + '"', 'какой-то текст 3'],
  [1, 2, 3],
];

downloadCSV(csvArr, 'example');
```

Как видно из примера, каждый массив в csvArr - это строка итогового CSV-файла. Естественно все управляющие символы должны быть экранированы, если в вашей строке есть ";", то вам нужно будет сделать по примеру второго массива.

Если вы подключили библиотеку, а не отдельные модули, то итоговый код будет выглядеть так:

```
import workWithNet from 'work-with-net';

const csvArr = [
  [1, 2, 3],
  ['какой-то текст 1', '"' + 'какой-то ; \\n текст 2' + '"', 'какой-то текст 3'],
  [1, 2, 3],
];

workWithNet.downloadCSV(csvArr, 'example');
```